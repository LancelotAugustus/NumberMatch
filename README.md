# NumberMatch 数字配对游戏

## 项目介绍

NumberMatch（数字配对）是一款经典数字消除游戏的Python实现。本项目提供了一个完整的游戏引擎，包括棋盘状态管理、配对规则验证、最优消除策略计算等功能。游戏采用9列网格结构，玩家需要找到可以配对的数字对进行消除，目标是将棋盘完全清空。

本项目不仅实现了游戏的核心逻辑，还包含一个智能求解器（Solver），能够判断给定棋盘布局的可解性，并提供最优的消除路径方案。求解器采用贪心前瞻算法，通过模拟评估每一步消除操作后的潜在消除数量，选择最优的消除序列。此外，项目还提供了孪生棋盘（TwinBoard）类作为辅助分析工具，通过将数字转换为互补数表示，简化配对逻辑，便于搜索和计算可行的配对方案。

项目代码结构清晰，注释完整，提供了全面的单元测试覆盖，确保代码质量和功能正确性。所有核心功能都有对应的测试用例，覆盖率达到100%，适合学习和二次开发使用。

## 核心功能

本项目提供了以下核心功能模块：

- **棋盘管理**：采用灵活高效的9列网格系统，使用一维列表存储数字，支持数字的添加、查询、配对消除等操作。棋盘结构设计简洁，便于扩展和维护。

- **配对规则实现**：完整实现了NumberMatch游戏的经典配对规则，支持数值相同配对和数值和为10配对两种方式。配对判断包含数字匹配和路径可达两个层面的验证。

- **路径验证**：对配对位置之间的路径进行全面检查，支持同行、相同列、对角线相邻、跨行首尾相邻四种路径类型，确保配对的合法性。

- **智能求解器**：采用贪心前瞻算法，在每一步选择对未来最有利的消除操作。求解器能够评估每种选择后的潜在消除数量，选择最优的消除路径。

- **孪生棋盘分析**：TwinBoard类将原始数字转换为互补数表示，将配对问题简化为"数值相等即可配对"的形式，便于计算当前局面的最优配对方案。

- **自动测试套件**：完整的pytest测试用例，覆盖所有核心功能和边界情况，确保代码的正确性和稳定性。

## 游戏规则

### 数字配对条件

两个数字可以配对的前提条件是满足以下任一规则：

**规则一：数值相同**  
两个位置的数字完全相等时可以配对。例如数字5可以与数字5配对，数字3可以与数字3配对。这是最直接的配对方式。

**规则二：和为10**  
两个位置的数字之和等于10时可以配对。例如数字3可以与数字7配对（3+7=10），数字1可以与数字9配对（1+9=10），数字4可以与数字6配对（4+6=10）。数字5只能与数字5配对，不能与其他数字配对，因为5+5=10但需要两个相同数字。

### 路径可达条件

在满足数字配对条件后，还需要检查两个位置之间的路径是否通畅。有效的配对路径必须满足以下任一拓扑关系，且路径上不能有非空数字阻挡：

**相同行**：两个位置位于同一行内，列索引可以相邻也可以间隔多格，但中间不能有非空数字。例如同一行中的第1个位置和第5个位置，如果中间都是空格，则可以配对。

**相同列**：两个位置位于同一列内，行索引可以相邻也可以间隔多格，中间不能有非空数字。这提供了垂直方向的配对可能性。

**对角线相邻**：两个位置位于同一对角线上，满足行索引加列索引等于常数（主对角线）或行索引减列索引等于常数（副对角线），且中间不能有非空数字。这提供了斜向的配对路径。

**跨行首尾相邻**：两个位置分别位于相邻两行的首尾位置。例如第1行最后一个位置和第2行第一个位置，这种特殊规则增加了配对的灵活性。

### 边界情况

在进行配对判断时，需要注意以下边界情况：

- 相同位置不能配对（两个位置索引相同时返回False）
- 任一位置为空（数字为0）时不能配对
- 跨行首尾配对仅适用于相邻两行
- 配对操作会直接修改棋盘状态，将配对的两个位置设为0

## 安装说明

### 环境要求

本项目要求Python 3.10或更高版本。您可以通过以下命令检查Python版本：

```bash
python --version
```

如果版本低于3.10，建议升级Python环境。您可以从Python官方网站下载最新版本，或者使用包管理器进行升级。

### 依赖安装

本项目的依赖管理使用pip，依赖项定义在requirements.txt文件中。安装步骤如下：

首先，进入项目根目录：

```bash
cd NumberMatch
```

然后，创建并激活虚拟环境（推荐）：

```bash
# 创建虚拟环境
python -m venv .venv

# Windows激活
.venv\Scripts\activate

# Linux/Mac激活
source .venv/bin/activate
```

最后，安装项目依赖：

```bash
pip install -r requirements.txt
```

当前项目的requirements.txt内容如下：

```
pytest~=9.0.2
```

这意味着项目主要依赖pytest测试框架，用于运行单元测试和生成测试报告。

## 使用指南

### 运行示例

项目提供了演示脚本main.py，可以直接运行查看求解器的效果：

```bash
python srcs/main.py
```

运行该命令将显示：
- 初始棋盘状态（使用"."表示空格）
- 逐步的配对消除过程
- 最终解法步骤数和详细路径

### API使用

#### Board类

Board类是游戏的核心数据结构，用于管理棋盘的数字状态。以下是基本使用示例：

```python
from srcs.board import Board

# 创建新棋盘
board = Board()

# 设置初始状态（0表示空格）
board.set_digits([2, 6, 8, 1, 5, 6, 5, 4, 9,
                  7, 5, 7, 4, 2, 0, 0, 0, 5,
                  6, 8, 1, 5, 9, 5, 0, 9, 2,
                  1, 5, 7, 6, 3, 4, 7, 6, 7,
                  8, 6, 1, 8, 1, 2])

# 显示棋盘（使用"."表示空格）
print(board)

# 执行配对消除（索引从0开始）
board.match(0, 8)  # 消除第1个和第9个位置的数字

# 填充剩余数字到底部
board.fill()
```

#### Solver类

Solver类用于判断棋盘是否可完全清空，并提供最优消除路径：

```python
from srcs.board import Board
from srcs.solver import Solver

# 创建并设置棋盘
board = Board()
board.set_digits([2, 6, 8, 1, 5, 6, 5, 4, 9,
                  7, 5, 7, 4, 2, 0, 0, 0, 5,
                  6, 8, 1, 5, 9, 5, 0, 9, 2,
                  1, 5, 7, 6, 3, 4, 7, 6, 7,
                  8, 6, 1, 8, 1, 2])

# 填充数字（根据游戏规则）
board.fill()

# 创建求解器并求解
solver = Solver()
solver.set_board(board)
is_solvable = solver.solve()

if is_solvable:
    moves = solver.get_solution()
    print(f"成功！共需 {len(moves)} 步消除")
    for i, (idx1, idx2) in enumerate(moves, 1):
        row1, col1 = divmod(idx1, 9)
        row2, col2 = divmod(idx2, 9)
        print(f"第{i}步：R{row1+1}C{col1+1} 配对 R{row2+1}C{col2+1}")
else:
    print("该棋盘无法完全清空。")
```

#### TwinBoard类

TwinBoard类提供辅助分析功能，通过数字转换简化配对逻辑：

```python
from srcs.board import Board
from srcs.twin_board import TwinBoard

# 创建棋盘
board = Board()
board.set_digits([1, 5, 3, 9, 2, 8, 4, 6, 7])

# 创建孪生棋盘（转换为互补数）
twin_board = TwinBoard(board)
# 原始数字：[1, 5, 3, 9, 2, 8, 4, 6, 7]
# 转换后：  [1, 5, 3, 1, 2, 2, 4, 4, 3]
# 转换规则：min(digit, 10 - digit)

# 获取分析数据
print(f"可达配对列表：{twin_board.digit_pairs}")
print(f"潜在配对数量：{twin_board.potential_num}")
```

### 索引系统

本项目统一使用0基索引（0-based indexing），即第一个元素的索引为0。索引系统包含三种类型：

- **全局索引**：元素在一维数字列表中的位置，范围从0到列表长度减1。通过公式global_index = 9 * row_index + col_index计算。

- **行索引**：元素在二维网格中的行位置，从0开始计数。例如第1行的行索引为0，第2行的行索引为1。

- **列索引**：元素在二维网格中的列位置，从0开始计数。例如第1列的列索引为0，第9列的列索引为8。

索引转换方法如下：

```python
# 全局索引转行列索引
row_index = global_index // 9
col_index = global_index % 9

# 行列索引转全局索引
global_index = 9 * row_index + col_index
```

## 项目结构

```
NumberMatch/
├── srcs/                          # 源代码目录
│   ├── __pycache__/              # Python字节码缓存
│   ├── board.py                  # Board类，核心游戏数据结构
│   ├── main.py                   # 演示程序入口
│   ├── solver.py                 # Solver类，智能求解器
│   └── twin_board.py             # TwinBoard类，辅助分析工具
├── tests/                         # 测试用例目录
│   ├── __pycache__/              # Python字节码缓存
│   ├── test_board.py             # Board类测试用例
│   ├── test_solver.py            # Solver类测试用例
│   └── test_twin_board.py        # TwinBoard类测试用例
├── docs/                          # 详细文档目录
│   ├── board.md                  # Board类API文档
│   ├── solver.md                 # Solver类API文档
│   └── twin_board.md             # TwinBoard类API文档
├── .gitignore                    # Git忽略规则配置
├── README.md                     # 本说明文档
├── requirements.txt              # Python依赖配置
└── glossary.md                   # 术语表
```

### 核心类说明

| 类名 | 所在文件 | 主要功能 |
|------|---------|---------|
| Board | srcs/board.py | 棋盘状态管理、数字存储、配对判断、消除操作 |
| TwinBoard | srcs/twin_board.py | 数字转换、配对分析、信息统计 |
| Solver | srcs/solver.py | 求解算法、最优路径计算、可解性判断 |

## 测试说明

本项目使用pytest作为测试框架，提供了完整的单元测试覆盖。

### 运行测试

运行所有测试用例：

```bash
pytest
```

运行测试并显示详细信息：

```bash
pytest -v
```

运行特定测试文件：

```bash
pytest tests/test_board.py        # Board类测试
pytest tests/test_solver.py       # Solver类测试
pytest tests/test_twin_board.py   # TwinBoard类测试
```

运行测试并查看代码覆盖率：

```bash
pytest --cov=srcs
```

### 测试文件说明

| 测试文件 | 测试对象 | 主要测试内容 |
|---------|---------|-------------|
| test_board.py | Board类 | 初始化、配对判断、消除操作、边界条件 |
| test_solver.py | Solver类 | 求解逻辑、路径记录、状态管理 |
| test_twin_board.py | TwinBoard类 | 数字转换、配对判断、信息更新 |

当前测试覆盖率达到100%，所有测试用例均通过，确保代码质量和功能正确性。

## API文档

### Board类

#### 初始化

```python
board = Board()
```

创建后，digit_list为空列表，表示一个空的棋盘状态。

#### 属性说明

**digit_list**  
类型：list[int]  
说明：存储棋盘所有数字的一维列表。列表长度为9×行数，每个元素为整数，其中0表示空格，1-9表示实际数字。

#### 方法说明

**set_digits(digit_list: list[int]) -> None**  
设置棋盘的当前局面，直接用提供的数字列表替换现有的digit_list。digit_list中的0表示空格位置。

**_can_match(global_index1: int, global_index2: int) -> bool**  
判断两个位置的数字是否满足配对条件。配对条件包括：数值相同或和为10。这是配对判断的第一层过滤条件。

**_is_matching(global_index1: int, global_index2: int) -> bool**  
判断两个位置是否满足配对消除条件。首先检查数字是否满足can_match条件，然后检查路径是否可达。路径类型包括：相同行、相同列、对角线相邻、跨行首尾相邻。

**match(global_index1: int, global_index2: int) -> None**  
执行配对消除操作。如果两个位置满足配对条件，则将对应位置设为0，然后调用_clear()清理空行。

**_clear() -> None**  
清理棋盘中的空行，将全为0的行移除，保留非空行，并将剩余数字压缩到顶部。

**fill() -> None**  
拷贝填充，将棋盘中剩余的非空数字复制到列表末尾。

### TwinBoard类

#### 初始化

```python
twin_board = TwinBoard(board: Board)
```

通过接收一个Board实例，将其数字列表转换为互补数表示，并计算初始的配对信息。转换规则为：digit_list[i] = min(original_digit, 10 - original_digit)。

#### 特有属性

**digit_pairs**  
类型：list[tuple[int, int]]  
说明：存储所有可达配对的位置对列表。每个元素是一个元组，包含两个全局索引，表示这两个位置可以配对消除。

**potential_num**  
类型：int  
说明：统计所有满足数字匹配条件的配对数量，用于评估局面的配对潜力。

#### 特有方法

**_update_information() -> None**  
更新配对信息，重新计算digit_pairs和potential_num。清空现有列表后，遍历所有位置对，累加满足条件的配对。

### Solver类

#### 初始化

```python
solver = Solver()
```

创建后，board为None，path为空列表。

#### 属性说明

**board**  
类型：TwinBoard或None  
说明：存储当前求解器正在处理的棋盘实例，初始值为None，通过set_board()方法设置。

**path**  
类型：List[Tuple[int, int]]  
说明：记录求解过程中选择的最优消除路径，按消除顺序存储所有配对操作。

#### 方法说明

**set_board(board: Board) -> None**  
设置求解器要处理的棋盘，接收Board实例并转换为TwinBoard类型进行求解计算。

**solve() -> bool**  
执行求解算法，判断当前棋盘是否能够被完全清空。采用贪心策略，在每一步选择能够产生最大潜在消除数量的数字对进行消除。返回True表示可以清空，返回False表示无法清空。

**get_solution() -> List[Tuple[int, int]]**  
获取求解过程中记录的最优消除路径，必须在solve()方法执行之后调用。

## 术语表

本术语表定义了项目中使用的主要术语，确保文档和代码的一致性理解。

**Board类（棋盘类）**  
负责管理数字游戏的棋盘状态，包括数字的存储、查询、匹配等功能的核心数据结构类。

**can_match（配对条件判断）**  
判断数字是否满足配对条件的方法。配对条件包括数值相同或和为10两个层面。

**clear（清理空行）**  
清理空行方法，用于移除棋盘中所有全0的行，并将剩余数字重新整理。

**col_index（列索引）**  
表示元素在棋盘二维网格中的列位置，从0开始计数。

**digit_grid（数字网格）**  
数字网格，二维列表结构，按9列排列的数字列表，用于以二维方式访问棋盘上的数字。

**digit_list（数字列表）**  
数字列表，一维列表结构，按全局索引顺序存储棋盘上的所有数字，使用0表示空格。

**digit_pairs（数字配对列表）**  
存储所有可达配对的位置对列表，在TwinBoard类中使用，每个元素是一个元组表示可配对的位置对。

**fill（拷贝填充）**  
拷贝填充方法，用于将未消除的数字复制到列表末尾。

**get_solution（获取解法）**  
获取最优消除路径的方法，返回求解器计算出的最优消除路径。

**global_index（全局索引）**  
表示元素在一维数字列表中的位置，从0开始计数。通过公式global_index = 9 * row_index + col_index计算。

**is_matching（配对判断）**  
判断是否配对方法，检测两个位置上的数字是否满足配对消除的条件，包括数字匹配和路径可达两个层面。

**match（配对消除）**  
配对消除方法，尝试对两个位置进行配对消除操作，若满足配对条件则将对应位置设置为0。

**path（消除路径）**  
消除路径列表，记录求解器在求解过程中每一步选择的配对，按消除顺序存储所有配对操作。

**potential_num（潜在配对数量）**  
潜在配对数量，在TwinBoard类中统计所有满足数字匹配条件的潜在配对数量，用于评估局面的配对潜力。

**row_index（行索引）**  
表示元素在棋盘二维网格中的行位置，从0开始计数。

**set_board（设置棋盘）**  
设置求解器所针对棋盘的方法，将传入的Board实例转换为TwinBoard进行分析。

**set_digits（设置局面）**  
设置局面方法，使用给定的数字列表初始化棋盘状态，数字列表中的0表示空格位置。

**solve（求解）**  
求解器的核心方法，判断是否能够清空棋盘，基于potential_num评估选择最优配对。

**Solver类（求解器类）**  
求解器类，负责计算数字配对消除的最优策略，通过模拟不同的配对选择评估潜在配对数量。

**TwinBoard（孪生棋盘类）**  
孪生棋盘类，继承自Board类的辅助分析工具，将数字转换为互补数表示以简化配对逻辑。

## 架构设计

### 核心组件

本项目采用经典的MVC架构模式，分为三个核心组件：

**Board（模型层）**  
作为游戏的核心数据结构，Board类维护游戏状态，使用一维列表表示棋盘。提供了完整的数据操作接口，包括数字存储、配对判断、消除操作、棋盘清理等功能。Board类的设计注重封装性，将内部实现细节（如下划线前缀的方法）隐藏，只暴露必要的公开接口。

**TwinBoard（分析层）**  
TwinBoard继承自Board类，作为辅助分析工具存在。其核心功能是将原始数字转换为互补数表示（每个数字转换为min(digit, 10 - digit)），从而将配对问题简化为"数值相等即可配对"的形式。这种转换使得配对判断逻辑更加简单，同时预计算所有可能的配对信息（digit_pairs和potential_num），为Solver提供高效的决策支持。

**Solver（控制层）**  
Solver类实现了游戏的求解算法，是整个项目的智能核心。它接收Board实例，转换为TwinBoard进行分析，然后采用贪心前瞻算法计算最优消除路径。求解器的设计遵循单一职责原则，只负责求解逻辑，不涉及棋盘的具体操作。

### 算法详解

求解器采用贪心前瞻算法，其核心思想是在每一步选择对未来最有利的操作。算法的关键在于评估标准的选取——使用potential_num作为评估指标，该指标反映了执行某步消除后棋盘剩余的可消除对数量。

**决策过程**如下：

1. 获取当前棋盘中所有可消除的数字对集合P = {p₁, p₂, ..., pₙ}
2. 对于每个数字对pᵢ：
   - 创建棋盘副本Sᵢ = copy.deepcopy(S)
   - 在Sᵢ上执行消除操作Sᵢ.match(pᵢ)
   - 计算Sᵢ.potential_num（后续可消除对数量）
3. 选择potential_num值最大的数字对p*作为最优选择
4. 在原棋盘上执行消除S.match(p*)
5. 重复上述过程直到无法继续消除或棋盘清空

**算法复杂度**：

| 复杂度类型 | 说明 |
|-----------|------|
| 时间复杂度 | O(n³)，其中n为数字数量 |
| 空间复杂度 | O(n²) |

时间复杂度来源于每一步需要遍历所有可消除对并创建深度副本。空间复杂度主要用于存储路径信息和深度副本。

### 设计原则

本项目的设计遵循以下原则：

- **封装性**：通过下划线前缀区分私有方法和公开接口，确保内部实现细节不被外部依赖。
- **单一职责**：每个类都有明确的职责范围，Board负责数据管理，TwinBoard负责分析转换，Solver负责求解计算。
- **可扩展性**：代码结构清晰，便于添加新功能或修改现有逻辑。
- **一致性**：命名规范统一，术语使用一致，代码风格统一。

## 许可证

本项目开源，仅供教育和个人使用。
