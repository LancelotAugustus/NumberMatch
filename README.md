# 🎮 NumberMatch 数字配对游戏

---

## ✨ 项目介绍

NumberMatch（数字配对）是一款经典数字消除游戏的 Python 实现。本项目提供了一个完整的游戏引擎，包括棋盘状态管理、配对规则验证、最优消除策略计算等功能。游戏采用
9 列网格结构，玩家需要找到可以配对的数字对进行消除，目标是将棋盘完全清空。

本项目不仅实现了游戏的核心逻辑，还包含一个 **智能求解器（Solver）**
，能够判断给定棋盘布局的可解性，并提供最优的消除路径方案。求解器采用贪心前瞻算法，通过模拟评估每一步消除操作后的潜在消除数量，选择最优的消除序列。此外，项目还提供了
**孪生棋盘（TwinBoard）** 类作为辅助分析工具，通过将数字转换为互补数表示，简化配对逻辑，便于搜索和计算可行的配对方案。

项目代码结构清晰，注释完整，提供了全面的单元测试覆盖，确保代码质量和功能正确性。所有核心功能都有对应的测试用例，覆盖率达到
100%，适合学习和二次开发使用。

---

## 🎯 核心功能

本项目提供了以下核心功能模块：

- **棋盘管理**：采用灵活高效的 9 列网格系统，使用一维列表存储数字，支持数字的添加、查询、配对消除等操作。棋盘结构设计简洁，便于扩展和维护。

- **配对规则实现**：完整实现了 NumberMatch 游戏的经典配对规则，支持数值相同配对和数值和为 10
  配对两种方式。配对判断包含数字匹配和路径可达两个层面的验证。

- **路径验证**：对配对位置之间的路径进行全面检查，支持同行、相同列、对角线相邻、跨行首尾相邻四种路径类型，确保配对的合法性。

- **智能求解器**：采用贪心前瞻算法，在每一步选择对未来最有利的消除操作。求解器能够评估每步选择后的潜在消除数量，选择最优的消除路径。

- **孪生棋盘分析**：TwinBoard 类将原始数字转换为互补数表示，将配对问题简化为"数值相等即可配对"的形式，便于计算当前局面的最优配对方案。

- **自动测试套件**：完整的 pytest 测试用例，覆盖所有核心功能和边界情况，确保代码的正确性和稳定性。

---

## 📐 游戏规则

### 数字配对条件

两个数字可以配对的前提条件是满足以下任一规则：

**规则一：数值相同**  
两个位置的数字完全相等时可以配对。例如数字 5 可以与数字 5 配对，数字 3 可以与数字 3 配对。这是最直接的配对方式。

**规则二：和为 10**  
两个位置的数字之和等于 10 时可以配对。例如数字 3 可以与数字 7 配对（3+7=10），数字 1 可以与数字 9 配对（1+9=10），数字 4 可以与数字
6 配对（4+6=10）。数字 5 只能与数字 5 配对，不能与其他数字配对，因为 5+5=10 但需要两个相同数字。

### 路径可达条件

在满足数字配对条件后，还需要检查两个位置之间的路径是否通畅。有效的配对路径必须满足以下任一拓扑关系，且路径上不能有非空数字阻挡：

**相同行**：两个位置位于同一行内，列索引可以相邻也可以间隔多格，但中间不能有非空数字。例如同一行中的第 1 个位置和第 5
个位置，如果中间都是空格，则可以配对。

**相同列**：两个位置位于同一列内，行索引可以相邻也可以间隔多格，中间不能有非空数字。这提供了垂直方向的配对可能性。

**对角线相邻**：两个位置位于同一对角线上，满足行索引加列索引等于常数（主对角线）或行索引减列索引等于常数（副对角线），且中间不能有非空数字。这提供了斜向的配对路径。

**跨行首尾相邻**：两个位置分别位于相邻两行的首尾位置。例如第 1 行最后一个位置和第 2 行第一个位置，这种特殊规则增加了配对的灵活性。

### 边界情况

在进行配对判断时，需要注意以下边界情况：

- 相同位置不能配对（两个位置索引相同时返回 False）
- 任一位置为空（数字为 0）时不能配对
- 跨行首尾配对仅适用于相邻两行
- 配对操作会直接修改棋盘状态，将配对的两个位置设为 0

---

## 🚀 安装说明

### 环境要求

本项目要求 Python 3.10 或更高版本。您可以通过以下命令检查 Python 版本：

```bash
python --version
```

如果版本低于 3.10，建议升级 Python 环境。您可以从 Python 官方网站下载最新版本，或者使用包管理器进行升级。

### 依赖安装

本项目的依赖管理使用 pip，依赖项定义在 `requirements.txt` 文件中。安装步骤如下：

首先，进入项目根目录：

```bash
cd NumberMatch
```

然后，创建并激活虚拟环境（推荐）：

```bash
# 创建虚拟环境
python -m venv .venv

# Windows 激活
.venv\Scripts\activate

# Linux/Mac 激活
source .venv/bin/activate
```

最后，安装项目依赖：

```bash
pip install -r requirements.txt
```

当前项目的 `requirements.txt` 内容如下：

```
pytest~=9.0.2
```

这意味着项目主要依赖 pytest 测试框架，用于运行单元测试和生成测试报告。

---

## 🎲 使用指南

### 运行示例

项目提供了演示脚本 `main.py`，可以直接运行查看求解器的效果：

```bash
python srcs/main.py
```

运行该命令将显示：

- 初始棋盘状态（使用 "." 表示空格）
- 逐步的配对消除过程
- 最终解法步骤数和详细路径

### API 使用

#### Board 类

Board 类是游戏的核心数据结构，用于管理棋盘的数字状态。以下是基本使用示例：

```python
from srcs.board import Board

# 创建新棋盘
board = Board()

# 设置初始状态（0 表示空格）
board.set_digits([2, 6, 8, 1, 5, 6, 5, 4, 9,
                  7, 5, 7, 4, 2, 0, 0, 0, 5,
                  6, 8, 1, 5, 9, 5, 0, 9, 2,
                  1, 5, 7, 6, 3, 4, 7, 6, 7,
                  8, 6, 1, 8, 1, 2])

# 显示棋盘（使用 "." 表示空格）
print(board)

# 执行配对消除（索引从 0 开始）
board.match(0, 8)  # 消除第 1 个和第 9 个位置的数字

# 填充剩余数字到底部
board.fill()
```

#### Solver 类

Solver 类用于判断棋盘是否可完全清空，并提供最优消除路径：

```python
from srcs.board import Board
from srcs.solver import Solver

# 创建并设置棋盘
board = Board()
board.set_digits([2, 6, 8, 1, 5, 6, 5, 4, 9,
                  7, 5, 7, 4, 2, 0, 0, 0, 5,
                  6, 8, 1, 5, 9, 5, 0, 9, 2,
                  1, 5, 7, 6, 3, 4, 7, 6, 7,
                  8, 6, 1, 8, 1, 2])

# 填充数字（根据游戏规则）
board.fill()

# 创建求解器并求解
solver = Solver()
solver.set_board(board)
is_solvable = solver.solve()

if is_solvable:
    moves = solver.get_solution()
    print(f"成功！共需 {len(moves)} 步消除")
    for i, (idx1, idx2) in enumerate(moves, 1):
        row1, col1 = divmod(idx1, 9)
        row2, col2 = divmod(idx2, 9)
        print(f"第{i}步：R{row1 + 1}C{col1 + 1} 配对 R{row2 + 1}C{col2 + 1}")
else:
    print("该棋盘无法完全清空。")
```

#### TwinBoard 类

TwinBoard 类提供辅助分析功能，通过数字转换简化配对逻辑：

```python
from srcs.board import Board
from srcs.twin_board import TwinBoard

# 创建棋盘
board = Board()
board.set_digits([1, 5, 3, 9, 2, 8, 4, 6, 7])

# 创建孪生棋盘（转换为互补数）
twin_board = TwinBoard(board)
# 原始数字：[1, 5, 3, 9, 2, 8, 4, 6, 7]
# 转换后：  [1, 5, 3, 1, 2, 2, 4, 4, 3]
# 转换规则：min(digit, 10 - digit)

# 获取分析数据
print(f"可达配对列表：{twin_board.pair_list}")
print(f"潜在配对数量：{twin_board.potential_pair_count}")
```

### 索引系统

本项目统一使用 0 基索引（0-based indexing），即第一个元素的索引为 0。索引系统包含三种类型：

- **全局索引**：元素在一维数字列表中的位置，范围从 0 到列表长度减 1。通过公式 `global_index = 9 * row_index + col_index`
  计算。

- **行索引**：元素在二维网格中的行位置，从 0 开始计数。例如第 1 行的行索引为 0，第 2 行的行索引为 1。

- **列索引**：元素在二维网格中的列位置，从 0 开始计数。例如第 1 列的列索引为 0，第 9 列的列索引为 8。

索引转换方法如下：

```python
# 全局索引转行列索引
row_index = global_index // 9
col_index = global_index % 9

# 行列索引转全局索引
global_index = 9 * row_index + col_index
```

---

## 📋 项目结构

```
NumberMatch/
├── srcs/                          # 源代码目录
│   ├── __pycache__/              # Python 字节码缓存
│   ├── board.py                  # Board 类，核心游戏数据结构
│   ├── main.py                   # 演示程序入口
│   ├── solver.py                 # Solver 类，智能求解器
│   └── twin_board.py             # TwinBoard 类，辅助分析工具
├── tests/                         # 测试用例目录
│   ├── __pycache__/              # Python 字节码缓存
│   ├── test_board.py             # Board 类测试用例
│   ├── test_solver.py            # Solver 类测试用例
│   └── test_twin_board.py        # TwinBoard 类测试用例
├── docs/                          # 详细文档目录
│   ├── board.md                  # Board 类 API 文档
│   ├── solver.md                 # Solver 类 API 文档
│   └── twin_board.md             # TwinBoard 类 API 文档
├── .gitignore                    # Git 忽略规则配置
├── README.md                     # 本说明文档
├── requirements.txt              # Python 依赖配置
└── glossary.md                   # 术语表
```

### 核心类说明

| 类名            | 所在文件                 | 主要功能                  |
|---------------|----------------------|-----------------------|
| **Board**     | `srcs/board.py`      | 棋盘状态管理、数字存储、配对判断、消除操作 |
| **TwinBoard** | `srcs/twin_board.py` | 数字转换、配对分析、信息统计        |
| **Solver**    | `srcs/solver.py`     | 求解算法、最优路径计算、可解性判断     |

---

## ✅ 测试说明

本项目使用 pytest 作为测试框架，提供了完整的单元测试覆盖。

### 运行测试

运行所有测试用例：

```bash
pytest
```

运行测试并显示详细信息：

```bash
pytest -v
```

运行特定测试文件：

```bash
pytest tests/test_board.py        # Board 类测试
pytest tests/test_solver.py       # Solver 类测试
pytest tests/test_twin_board.py   # TwinBoard 类测试
```

运行测试并查看代码覆盖率：

```bash
pytest --cov=srcs
```

### 测试文件说明

| 测试文件                 | 测试对象        | 主要测试内容             |
|----------------------|-------------|--------------------|
| `test_board.py`      | Board 类     | 初始化、配对判断、消除操作、边界条件 |
| `test_solver.py`     | Solver 类    | 求解逻辑、路径记录、状态管理     |
| `test_twin_board.py` | TwinBoard 类 | 数字转换、配对判断、信息更新     |

当前测试覆盖率达到 100%，所有测试用例均通过，确保代码质量和功能正确性。

---

## 📖 API 文档

### Board 类

#### 初始化

```python
board = Board()
```

创建后，`digit_list` 为空列表，表示一个空的棋盘状态。

#### 属性说明

**`digit_list`**

- 类型：`list[int]`
- 说明：存储棋盘所有数字的一维列表。列表长度为 9×行数，每个元素为整数，其中 0 表示空格，1-9 表示实际数字。

#### 方法说明

**`set_digits(digit_list: list[int]) -> None`**  
设置棋盘的当前局面，直接用提供的数字列表替换现有的 `digit_list`。`digit_list` 中的 0 表示空格位置。

**`_can_match(global_index1: int, global_index2: int) -> bool`**  
判断两个位置的数字是否满足配对条件。配对条件包括：数值相同或和为 10。这是配对判断的第一层过滤条件。

**`_is_matching(global_index1: int, global_index2: int) -> bool`**  
判断两个位置是否满足配对消除条件。首先检查数字是否满足 `_can_match` 条件，然后检查路径是否可达。路径类型包括：相同行、相同列、对角线相邻、跨行首尾相邻。

**`match(global_index1: int, global_index2: int) -> None`**  
执行配对消除操作。如果两个位置满足配对条件，则将对应位置设为 0，然后调用 `_clear()` 清理空行。

**`_clear() -> None`**  
清理棋盘中的空行，将全为 0 的行移除，保留非空行，并将剩余数字压缩到顶部。

**`fill() -> None`**  
拷贝填充，将棋盘中剩余的非空数字复制到列表末尾。

### TwinBoard 类

#### 初始化

```python
twin_board = TwinBoard(board: Board)
```

通过接收一个 `Board` 实例，将其数字列表转换为互补数表示，并计算初始的配对信息。转换规则为：
`digit_list[i] = min(original_digit, 10 - original_digit)`。

#### 特有属性

**`digit_pairs`**

- 类型：`list[tuple[int, int]]`
- 说明：存储所有可达配对的位置对列表。每个元素是一个元组，包含两个全局索引，表示这两个位置可以配对消除。

**`potential_num`**

- 类型：`int`
- 说明：统计所有满足数字匹配条件的配对数量，用于评估局面的配对潜力。

#### 特有方法

**`_update_information() -> None`**  
更新配对信息，重新计算 `digit_pairs` 和 `potential_num`。清空现有列表后，遍历所有位置对，累加满足条件的配对。

### Solver 类

#### 初始化

```python
solver = Solver()
```

创建后，`board` 为 `None`，`path` 为空列表。

#### 属性说明

**`board`**

- 类型：`TwinBoard` 或 `None`
- 说明：存储当前求解器正在处理的棋盘实例。初始值为 `None`，通过 `set_board()` 方法进行设置。

**`path`**

- 类型：`List[Tuple[int, int]]`
- 说明：记录求解过程中选择的最优消除路径。每一步消除操作由一个包含两个整数的元组表示，代表要消除的数字对。

#### 方法说明

**`set_board(board: Board) -> None`**  
设置求解器要处理的棋盘。该方法接收一个 `Board` 实例，将其转换为 `TwinBoard` 类型的内部表示，以便进行求解计算。

**`solve() -> bool`**  
执行求解算法，判断当前棋盘是否能够被完全清空。该方法采用贪心策略，在每一步选择能够产生最大潜在消除数量的数字对进行消除。返回
`True` 表示可以清空，返回 `False` 表示无法清空。

**`get_solution() -> List[Tuple[int, int]]`**  
获取求解过程中记录的最优消除路径。该方法必须在 `solve()` 方法执行之后调用，返回的路径包含了求解器选择的所有消除操作序列。

---

## 📚 术语表

本术语表定义了项目中使用的主要术语，确保文档和代码的一致性理解。

**Board 类（棋盘类）**  
负责管理数字游戏的棋盘状态，包括数字的存储、查询、匹配等功能的核心数据结构类。

**can_match（配对条件判断）**  
判断数字是否满足配对条件的方法。配对条件包括数值相同或和为 10 两个层面。

**clear（清理空行）**  
清理空行方法，用于移除棋盘中所有全 0 的行，并将剩余数字重新整理。

**col_index（列索引）**  
表示元素在棋盘二维网格中的列位置，从 0 开始计数。

**digit_grid（数字网格）**  
数字网格，二维列表结构，按 9 列排列的数字列表，用于以二维方式访问棋盘上的数字。

**digit_list（数字列表）**  
数字列表，一维列表结构，按全局索引顺序存储棋盘上的所有数字，使用 0 表示空格。

**digit_pairs（数字配对列表）**  
存储所有可达配对的位置对列表，在 `TwinBoard` 类中使用，每个元素是一个元组表示可配对的位置对。

**fill（拷贝填充）**  
拷贝填充方法，用于将未消除的数字复制到列表末尾。

**get_solution（获取解法）**  
获取最优消除路径的方法，返回求解器计算出的最优消除路径。

**global_index（全局索引）**  
表示元素在一维数字列表中的位置，从 0 开始计数。通过公式 `global_index = 9 * row_index + col_index` 可与二维坐标相互转换。

**is_matching（配对判断）**  
判断是否配对方法，检测两个位置上的数字是否满足配对消除的条件，包括数字匹配和路径可达两个层面。

**match（配对消除）**  
配对消除方法，尝试对两个位置进行配对消除操作，若满足配对条件则将对应位置设置为 0。

**path（消除路径）**  
消除路径列表，记录求解器在求解过程中每一步选择的配对。在 `Solver` 类中，每个元素是一个元组 `(global_index1, global_index2)`
，按消除顺序存储所有配对操作。

**potential_num（潜在配对数量）**  
潜在配对数量，在 `TwinBoard` 类中统计所有满足数字匹配条件（数值相等）的潜在配对数量，用于评估局面的配对潜力。

**row_index（行索引）**  
表示元素在棋盘二维网格中的行位置，从 0 开始计数。

**set_board（设置棋盘）**  
设置求解器所针对棋盘的方法。将传入的 `Board` 实例转换为 `TwinBoard` 进行分析，用于准备求解所需的棋盘数据。

**set_digits（设置局面）**  
设置局面方法，使用给定的数字列表初始化棋盘状态，数字列表中的 0 表示空格位置。

**solve（求解）**  
求解器的核心方法，判断是否能够清空棋盘。该方法循环选择当前局面中潜力最大的配对进行消除（基于 `potential_num`
评估），直到无法继续或清空棋盘。返回布尔值表示是否能够完全清空棋盘。

**Solver 类（求解器类）**  
求解器类，负责计算数字配对消除的最优策略。通过模拟不同的配对选择，评估每种选择的潜在配对数量（`potential_num`），选择最优的消除路径（
`path`）。

**TwinBoard（孪生棋盘类）**  
孪生棋盘类，继承自 `Board` 类的辅助分析工具。该类将原始棋盘的数字转换为互补数表示（每个数字转换为 `min(digit, 10 - digit)`
），从而将配对问题简化为"数值相等即可配对"的形式。主要用于计算当前局面的最优配对方案，提供 `digit_pairs` 和 `potential_num`
等配对信息。

---

## 🏗️ 架构设计

### 核心组件

本项目采用经典的 MVC 架构模式，分为三个核心组件：

**Board（模型层）**  
作为游戏的核心数据结构，Board 类维护游戏状态，使用一维列表表示棋盘。提供了完整的数据操作接口，包括数字存储、配对判断、消除操作、棋盘清理等功能。Board
类的设计注重封装性，将内部实现细节（如下划线前缀的方法）隐藏，只暴露必要的公开接口。

**TwinBoard（分析层）**  
TwinBoard 继承自 Board 类，作为辅助分析工具存在。其核心功能是将原始数字转换为互补数表示（每个数字转换为
`min(digit, 10 - digit)`），从而将配对问题简化为"数值相等即可配对"的形式。这种转换使得配对判断逻辑更加简单，同时预计算所有可能的配对信息（
`digit_pairs` 和 `potential_num`），为 Solver 提供高效的决策支持。

**Solver（控制层）**  
Solver 类实现了游戏的求解算法，是整个项目的智能核心。它接收 Board 实例，转换为 TwinBoard
进行分析，然后采用贪心前瞻算法计算最优消除路径。求解器的设计遵循单一职责原则，只负责求解逻辑，不涉及棋盘的具体操作。

### 算法详解

求解器采用贪心前瞻算法，其核心思想是在每一步选择对未来最有利的操作。算法的关键在于评估标准的选取——使用 `potential_num`
作为评估指标，该指标反映了执行某步消除后棋盘剩余的可消除对数量。

**决策过程**如下：

1. 获取当前棋盘中所有可消除的数字对集合 `P = {p₁, p₂, ..., pₙ}`
2. 对于每个数字对 `pᵢ`：
    - 创建棋盘副本 `Sᵢ = copy.deepcopy(S)`
    - 在 `Sᵢ` 上执行消除操作 `Sᵢ.match(pᵢ)`
    - 计算 `Sᵢ.potential_num`（后续可消除对数量）
3. 选择 `potential_num` 值最大的数字对 `p*` 作为最优选择
4. 在原棋盘上执行消除 `S.match(p*)`
5. 重复上述过程直到无法继续消除或棋盘清空

**算法复杂度**：

| 复杂度类型 | 说明               |
|-------|------------------|
| 时间复杂度 | O(n³)，其中 n 为数字数量 |
| 空间复杂度 | O(n²)            |

时间复杂度来源于每一步需要遍历所有可消除对并创建深度副本。空间复杂度主要用于存储路径信息和深度副本。

### 设计原则

本项目的设计遵循以下原则：

- **封装性**：通过下划线前缀区分私有方法和公开接口，确保内部实现细节不被外部依赖。
- **单一职责**：每个类都有明确的职责范围，Board 负责数据管理，TwinBoard 负责分析转换，Solver 负责求解计算。
- **可扩展性**：代码结构清晰，便于添加新功能或修改现有逻辑。
- **一致性**：命名规范统一，术语使用一致，代码风格统一。

---

## 📄 许可证

本项目开源，仅供教育和个人使用。
