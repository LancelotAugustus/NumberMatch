# Solver 类功能说明文档

## 类概述

**模块：** `srcs.solver`

**类名：** `Solver`

**设计目的：** `Solver` 类是
NumberMatch（数字配对）游戏的核心求解器组件，负责判断给定的棋盘布局是否能够被完全清空，并提供最优的消除路径方案。该类采用模拟评估算法，通过前瞻性地评估每一步消除操作后的潜在消除数量，选择最优的消除序列，从而实现对棋盘的可解性判断。

**核心特性：**

- 采用贪心前瞻算法，在每一步选择对未来最有利的消除操作
- 通过模拟消除过程评估不同方案的潜在消除数量
- 记录最优消除路径，支持回溯分析

**使用场景：**

- 验证特定棋盘布局的可解性
- 为玩家提供提示或自动解题功能
- 在游戏开发阶段测试关卡设计的合理性

## 属性说明

### `board`

- **类型：** `TwinBoard` 或 `None`
- **说明：** 存储当前求解器正在处理的棋盘实例。初始值为 `None`，通过 `set_board()` 方法进行设置。该属性在求解过程中被修改，记录当前棋盘状态。

### `path`

- **类型：** `List[Tuple[int, int]]`
- **说明：** 记录求解过程中选择的最优消除路径。每一步消除操作由一个包含两个整数的元组表示，代表要消除的数字对。该列表按照消除顺序存储所有已执行的消除操作。

## 方法说明

### `__init__`

```python
def __init__(self)
```

**功能描述：** 初始化 `Solver` 实例，创建一个空的求解器。将棋盘属性设置为 `None`，路径列表设置为空列表。

**参数：** 无

**返回值：** 无

---

### `set_board`

```python
def set_board(self, board: Board) -> None
```

**功能描述：** 设置求解器要处理的棋盘。该方法接收一个 `Board` 实例，将其转换为 `TwinBoard` 类型的内部表示，以便进行求解计算。

**参数：**

| 参数名     | 类型      | 说明           |
|---------|---------|--------------|
| `board` | `Board` | 原始的 Board 实例 |

**返回值：** `None`

---

### `solve`

```python
def solve(self) -> bool
```

**功能描述：** 执行求解算法，判断当前棋盘是否能够被完全清空。该方法采用贪心策略，在每一步选择能够产生最大潜在消除数量的数字对进行消除。

**参数：** 无

**返回值：** `bool` - 如果棋盘能够被完全清空则返回 `True`，否则返回 `False`

**算法流程：**

1. 当棋盘中存在可消除的数字对时，循环执行以下操作：
    - 遍历所有可消除的数字对
    - 对每个数字对，模拟消除后的棋盘状态
    - 计算模拟后棋盘的 `potential_num`（潜在消除数量）
    - 选择产生最大潜在消除数量的数字对作为最优选择
    - 执行最优消除操作，并将该操作记录到路径中

2. 如果消除后棋盘的数字列表为空，说明棋盘被完全清空，返回 `True`

3. 如果所有可消除的数字对都已处理完毕但棋盘仍未清空，返回 `False`

---

### `get_solution`

```python
def get_solution(self) -> List[Tuple[int, int]]
```

**功能描述：** 获取求解过程中记录的最优消除路径。该方法必须在 `solve()` 方法执行之后调用，返回的路径包含了求解器选择的所有消除操作序列。

**参数：** 无

**返回值：** `List[Tuple[int, int]]` - 消除路径列表，每个元素是一个包含两个整数的元组，表示需要消除的数字对

---

## 算法详解

### 核心策略

求解器采用**贪心前瞻算法**，其核心思想是在每一步选择对未来最有利的操作。该算法的关键在于评估标准的选取——使用
`potential_num` 作为评估指标，该指标反映了执行某步消除后棋盘剩余的可消除对数量。

### 决策过程

对于当前棋盘状态 `S`，算法执行以下决策过程：

1. 获取所有可消除的数字对集合 `P = {p₁, p₂, ..., pₙ}`
2. 对于每个数字对 `pᵢ`：
    - 创建棋盘副本 `Sᵢ = copy.deepcopy(S)`
    - 在 `Sᵢ` 上执行消除操作 `Sᵢ.match(pᵢ)`
    - 计算 `Sᵢ.potential_num`（后续可消除对数量）
3. 选择 `potential_num` 值最大的数字对 `p*`
4. 在原棋盘上执行消除 `S.match(p*)`
5. 重复上述过程直到无法继续消除或棋盘清空

### 算法复杂度

| 复杂度类型 | 说明               |
|-------|------------------|
| 时间复杂度 | O(n³)，其中 n 为数字数量 |
| 空间复杂度 | O(n²)            |

**说明：**

- 时间复杂度来源于每一步需要遍历所有可消除对并创建深度副本
- 空间复杂度主要用于存储路径信息和深度副本

---

## 方法访问级别说明

本类中的方法按照访问级别分为以下几类：

| 方法名                                  | 访问级别 | 说明                |
|--------------------------------------|------|-------------------|
| `__init__`                           | 特殊方法 | Python 特殊方法，用于初始化 |
| `set_board`, `solve`, `get_solution` | 公开   | 公开接口，供外部代码调用      |

**设计原则：** `Solver` 类提供简洁的求解接口，公开方法封装了核心求解逻辑，便于外部代码集成和使用。

---

## 注意事项

1. **fill() 方法的影响**：如果调用 `TwinBoard` 的 `fill()` 方法，配对信息不会自动更新，需要手动调用 `_update_information()`
   以反映新的棋盘状态。
